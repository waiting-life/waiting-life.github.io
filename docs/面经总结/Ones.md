## 笔试

**1. 原生js中异步代码有哪些？**

1. 事件监听
2. 回调
3. Promise.then
4. Async await
5. 网络io

**2. 如何通俗的理解mysql中的三个范式**

- 第一范式（1NF）
  指在关系模型中，对于添加的一个规范要求，所有的域都应该是原子性的，即数据库表的每一列都是不可分割的原子数据项，而不能是集合，数组，记录等非原子数据项。即实体中的某个属性有多个值时，必须拆分为不同的属性。在符合第一范式（1NF）表中的每个域值只能是实体的一个属性或一个属性的一部分。简而言之，第一范式就是无重复的域。
- 第二范式（2NF）
  在1NF的基础上，非码属性必须完全依赖于候选码（在1NF基础上消除非主属性对主码的部分函数依赖）
- 第三范式（3NF）
  在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖

通俗理解

- 第一范式：表中的字段不能再分割。是最小的单位。
- 第二范式：表中的非主键元素只能通过所有主键查出。例如，当主键为两个时，只有同时通过这两个主键才能查出某个属性，单独一个主键不能
- 第三范式：表中的非主键元素之间没有依赖关系。即不能通过一个得到另一个。

**3. 在react中如何避免不必要的渲染**

1. React.memo()：React.memo 是通过**浅比较**的方式对比变化前后的 props 与 state，这种方式很容易失效，那就是使用**箭头函**数。箭头函数在每次调用 render 时都会动态生成一个新的函数，函数的引用变化了，这时即便使用 React.memo 也是无效的

2. PureComponent：PureComponent 将会在 shouldComponentUpdate 中对组件更新前后的 props 和 state 进行浅比较，并根据浅比较的结果，决定是否需要继续更新流程。

   ``` js
   class App extends React.PureComponent {
     
   }
   
   function App2() {
     
   }
   
   export default React.memo(App2)
   
   ```

   

**4. 删除链表中的非递增节点**



**5. 什么是高阶函数？什么时候用高阶函数**

**高阶函数：**

高阶函数是一个接收函数作为参数或将函数作为输出返回的函数。

**高阶函数使用场景：**

函数节流

函数防抖

回调函数

**6. CSS选择器优先级顺序**

!important > 内联选择器>Id选择器>类选择器>标签选择器>*

**7. 业务系统中如何防止重复请求**



**8. 什么事消息队列？使用场景**



**9. select * from 'xxx' 和 select some   file ...性能区别？什么时候应该使用哪个**



**10. 列举最少四种进程间通信手段**

## Ones一面

**1. 用到了什么技术栈，微前端的原理，怎么实现的**

**当微应用信息注册完之后，一旦浏览器的 url 发生变化，便会自动触发 qiankun 的匹配逻辑，所有 activeRule 规则匹配上的微应用就会被插入到指定的 container 中，同时依次调用微应用暴露出的生命周期钩子。**



注册主应用

在主应用中注册子应用

**路由劫持**

在有了子应用列表之后，我们需要启动微前端以便渲染相应的子应用，也就是根据路由来渲染对应的子应用。

1. 重写 `pushState` 以及 `replaceState` 方法，在方法中调用原有方法后执行如何处理子应用的逻辑
2. 监听 `hashchange` 及 `popstate` 事件，事件触发后执行如何处理子应用的逻辑
3. 重写监听 / 移除事件函数，如果应用监听了 `hashchange` 及 `popstate` 事件就将回调函数保存起来以备后用



**2. 为什么要换工作，两三年后的规划**

薪资待遇

**3. 技术上的难点，比较有成就的地方**



**4. 为什么使用react-hooks**

+ 通过hooks给函数式组件引入了内部的一些状态，比如useState，还可以通过useEffect执行副作用，当依赖项改变的时候，执行回调函数，可以用来模拟class组件的生命周期。

**5. 为什么hooks不能放在条件判断里面，为什么使用hooks**

hooks的值存储在一个链式存储区。组件每次渲染的时候hook就会根据它的位置去取对应的值。所以要保证每次渲染的时候hook出现的顺序是一致的。如果放到条件判断里面的话就会不一致了。取值的时候就会取到错误的值，渲染就会出现问题。

**6. 为什么使用函数式组件不使用类组件**

函数式组件更方便

**组件传参**

类组件需要用this来饮用

函数式组件作为函数参数传递

**state和生命周期**

函数式组件没有生命周期和state，可以通过hooks来实现state和一些副作用，比如通过useState来实现状态管理，useEffect来模拟组件的生命周期

函数式组件捕获了渲染时所使用的值，函数式组件真正将数据和渲染紧紧的绑定在一起了。

**7. 单页面应用，页面卡顿怎么优化**

首屏加载慢

1. 首先找是为什么卡顿，看卡顿原因
2. 如果是首屏加载慢的话，可以进行路由懒加载，骨架屏，图片懒加载，减少文件体积，减少请求
3. 也有可能是接口请求时间太长
4. 复杂组件重复渲染，将组件变成纯组件。一个函数组件当props或者内部的state改变的组件会进行重复渲染，或者是父组件渲染，引起子组件，可以通过react.memo使组件变成一个纯组件，只有在对应的依赖改变的时候重新渲染组件。

**8. 为什么说一切皆函数**



**9. js怎么实现类，什么是原型链**

构造函数

**10. 数据库的事务**

希望好几次修改是一起成功的
