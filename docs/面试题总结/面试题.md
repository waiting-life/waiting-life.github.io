### ==和===
==会强制类型转换，并且比较不同类型的操作数
相等运算符(==和!=)使用**抽象相等比较算**法比较两个操作数。
+ 如果两个操作数都是对象，则仅当两个对象都引用到同一个对象上时才返回true
+ 如果一个操作数是null，另一个操作数是undefined，则返回true。比较相等性之前，不能将null和undefined转换成其他任何值
+ 如果两个操作数是不同类型的，就会尝试在比较前将他们转为成相同类型
  + 如果是数字与字符串比较，就会尝试将字符串转为数字值
  + 如果操作数之一是boolean值，则将操作转为1或者0
  + 如果操作数之一是对象，另一个是字符串或者数字，会尝试使用对象的valueOf和toString方法将对象转为原始值。

```js
null == undefined // true
1 == '1' // true
'1' == 1 // true
0 == false // true
0 == null // false
0 == undefined //false

const str1 = 'hello'
const str2 = new String('hello') 
str1 == str2 // true
```
**注意**
```js
+0 == -0 // true
true == true // true
false == false // true

// 如果任一操作数为NaN则返回false
'aaa' == NaN // false
```
`===`严格等于运算符不进行类型转换

### `[] == ![]`和`[] == []`的值
1. !运算符的优先级大于 `==`， ！会将后面的值转化为布尔值即`![] 变成 !Boolean([])`，也就是`!true`，也就是false. 
2. 实际上是对比`[] == false`
运算上面的顺序，false是布尔值，所以转化为数值`Number(false)`为0.
3. 对比`[] == 0`
满足第三条规则，`[]`是对象（数组也属于对象），0不是对象。所以`ToPrimitive`([])是`""`
4. 对比`"" == 0`
满足第二条规则，`""`是字符串，0是数值，对比`Number(0) == 0`，也就是 `0 == 0`
所以得出`[] == ![]`

```js
[] == false // true
[] == true // false
[] == 0 // true
({} == 0) //  false
// 1
if ([]) {
    console.log(1)
} else {
    console.log(2)
} 

// 3
if({}) {
    console.log(3)
} else {
    console.log(4)
}

// 5
if([] == false) {
    console.log(5)
} else {
    console.log(6)
}

// 8
if({} == false) {
    console.log(7)
} esle {
    console.log(8)
}
```
### []+0, {}+0
```js
[]+0 // '0'
{}+0 // NaN
```
