
## CSS
1. css flex 的各个属性值
   
2. background
背景颜色  背景图片地址 背景平铺  背景图像滚动 背景图片位置


3. css 动画 animation 各个时间值含义；
animation-name
animation-duration
animation-timing-function
animation-delay
animation-iteration-count
animation-direction
animation-fill-mode
4. css 如何实现让一个元素旋转并横向移动，只用一个 css 属性
```css
transform: translateX(1000px) rotate(360deg);
```

5.  解决 img 图片自带边距的问题
6.  介绍一下你对浏览器内核的理解
7.  CSS3有哪些新特性？
    1. CSS3实现圆角（border-radius），阴影（box-shadow），
    2. 对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform）
    3. transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);// 旋转,缩放,定位,倾斜
    4. 增加了更多的CSS选择器 多背景 rgba
    5. 在CSS3中唯一引入的伪元素是 ::selection.
    6. 媒体查询，多栏布局
    7. border-image

8.  css 中可以让文字在垂直和水平方向上重叠的两个属性是什么？
　　垂直方向：line-height
　　水平方向：letter-spacing (letter-spacing 属性增加或减少字符间的空白)
　　那么问题来了，关于letter-spacing的妙用知道有哪些么？
　　答案:可以用于消除inline-block元素间的换行符空格间隙问题。

9. rgba() 和 opacity 的透明效果有什么不同？
rgba()和opacity都能实现透明效果，但最大的不同是opacity作用于元素，以及元素内的所有内容的透明度，
　　而rgba()只作用于元素的颜色或其背景色。（设置rgba透明的元素的子元素不会继承透明效果！）

10. 什么是外边距重叠？重叠的结果是什么？
11. CSS 伪类和伪元素的区别
12. 什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？

响应式网站设计(Responsive Web design)是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。

基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理。

页面头部必须有meta声明的viewport。

13. 说一下 css 盒模型，border-box 和 content-box 区别
14. 说说 BFC
15. 移动端响应式布局怎么实现的；
16. 说一说 flex 布局，有了解 Grid 么
17. 有兼容 retina 屏幕的经历吗？如何在移动端实现 1 px 的线;
18. grid布局

## JavaScript
1. js数据类型、区别 
基本类型:number,string,boolean,null,undefined,
引用类型:object

2. 说说typeof和instanceof
3. 说说new操作符
4. 说说事件循环

当我们点击了一个元素的时候，这个点击事件首先会从外层元素开始向内传播，叫做事件捕获，到达目标元素后，又会从目标元素开始向外冒泡
5. Promise 的用法？了解 allSettled 方法么，怎么实现？
6. 闭包

闭包是一个有权访问函数作用域的函数。因为外层作用域无法读取内层作用域的变量，所以我们可以在内层作用域中返回一个函数，该函数可以读取到内层作用域声明的变量
7. ES5 实现继承的方法

比如我们声明两个构造函数Animal，Person
Animal.call(this, ...args)
通过Person.prototype = Object.create(Animal.prototype), new Person的时候，该实例的__proto__属性指向Person.prototype, Person.prototype.___proto__又指向了Animal.prototype
Person.prototype.constructor = Person

实现继承
   我们希望子类的原型的__proto__指向父类的原型对象Person.prototype = Object.create(Animal.prototype)
   子类的构造函数要复用父类构造函数Animal.call(this, ...args)
1. 说说作用域链

作用域有全局作用域和函数作用域，全局作用域中声明的变量在函数作用域中也可以使用，但是函数作用域中声明的变量在全局中无法读取
当我们使用一个变量的时候，首先会在当前作用域中找有没有这个变量，有的话直接使用该作用域中的值，
如果没有的话就会在上一级作用域中找，直到全局作用域
9. 函数式编程与面向对象的区别，优缺点

## 浏览器网络相关

1. http2 与 http1.1 区别，了解 http3 么

2. tcp 与 udp

3. 性能优化


4. http缓存

浏览器缓存分为强制缓存和协商缓存
当我们向服务器请求资源时，首先会查看浏览器是否有资源的缓存，如果没有的话会直接向服务器发送请求
如果有，首先我们会通过expires或者cache-control：max-age=xxx查看缓存是否过期
  如果没有过期，则直接读取缓存中的资源，这一步叫做强制缓存
  如果缓存过期了，通过向服务器发送请求，请求头携带if-none-match if-modified-since查看资源是否被修该
  如果没有修该，服务器返回304状态码，表示资源没有被修该，可以直接读取缓存中的资源
  如果资源修该了，服务器返回200的状态码，并且返回新的资源
这一步叫做协商缓存
5. 说说跨域


6. options预检请求作用


询问服务器是否允许我们带上这个请求头或者请求方法

1. XSS攻击和CSRF攻击


2. 为什么说CSRF攻击是利用网页利用浏览器信任？


3.  状态码 304怎么做 Cache-control有几个属性？

1xx 
200 响应成功
304 缓存
301 永久重定向
302 临时重定向
404 请求的资源不存在
500 服务器错误

1.  tcp与udp区别

tcp是可靠的，面向连接的传输层协议
udp是不可靠的，面向无连接的传输层控制协议

11. tcp如何保证数据稳定？


12. cdn原理，cdn回源怎么做


13. 进程与线程区别，线程间通信方式


14. tcp三次握手，四次挥手，为什么要三次握手，可以二次握手吗

tcp三次握手
tcp服务端会监听tcp客户端的连接请求
   + tcp客户端向tcp服务端发起tcp连接请求  SYN=1  seq=x（tcp客户处于同步已发送阶段
   + tcp服务端收到后，发送对tcp连接请求的确认  SYN=1 ACK=1 seq=y ack=x+1（tcp服务器处于同步已接受阶段
   + tcp客户端收到tcp服务端的确认后，发送对tcp服务端确认请求的确认，连接已建立

四次挥手：
  客户端向服务端发送tcp连接释放 FIN=1 ACK=1（中止等待1状态FIN-WAIT-1
  服务端收到后，因为服务端还有可能又数据在传输，就会处于关闭等待阶段，会发送客户端一个普通的确认  ACK=1
客户端收到后，处于中止等待2FIN-WAIT-2
  服务端数据都传送完之后，发送tcp连接始放确认 FIN=1 ACK=1
  客户端收到后处于TIME-WAIT 并向服务端发送确认 ACK=1 
  服务端收到后就会释放连接
  客户端就会在2msl之后关闭连接

不能二次握手
因为比如我们是二次握手的话，假如客户端——>服务端发送的连接请求失效了，没有收到tcp服务端的确认，就会超时重发，这次tcp服务端收到并发送确认后，客户端和服务端建立连接，然后传送数据，最后释放四次挥手释放连接。客户端和服务器都处于关闭状态，这时候如果之前失效的tcp连接请求发送到tcp服务器后，tcp服务器就会向客户端发送确认报文，但是因为tcp客户端已经关闭，并不会理会服务器。服务器没收到就会不断的超时重发，浪费资源
15. https中 get post安全性
16. 进程线程

## 算法
1. 手写在 给定的 n 个数中随机取出 m 个数，要求等概率
2. 实现斐波纳切数，递归和非递归的时间复杂度分别是多少
3. 希尔排序，堆排，快排；
4. 二维数组中的查找
5. 从先序遍历还原二叉树
6. 手写一个版本比较函数
7. 实现一下 cache request（请求过的数据不再请求）
8. 实现模版字符串
9. 统计字符串中每个字符出现的次数

```js
const str = 'aabbbcccddd111222'
const arr = Array.from(str)
function getNewData(arr) {
    const newData = {}
    for(const s of arr) {
        if(!newData[s]) {
            newData[s] = 1
        } else {
            newData[s]++ 
        }
    }
    return newData
}
getNewData(arr)
{1: 3, 2: 3, a: 2, b: 3, c: 3, d: 3}
```
10. js实现快排，时间复杂度O（nlogn）、空间复杂度
11. 手写代码，二叉树遍历

## git
1. git reset 与 revert 区别，revert 多个 mr 改如何处理
2. git 如何撤回 add 后的内容；

## 代码题

### 结构转换

```js
let oriArray = [
    {
        id: 4, text: '第四条',
    },
    {
        id: 2, text: '第二条', parent: 3
    },
    {
        id: 3, text: '第三条',
    },
    {
        id: 6, text: '第六条', parent: 5
    },
    {
        id: 5, text: '第五条', parent: 1,
    },
    {
        id: 1, text: '第一条', parent: 3
    },
]
function arrayToTree(arr) {
    const arr1 = [], arr2 = [], obj = {}
    for(let i = 0; i < arr.length; i++) {
        let item = arr[i]
        if(arr[i].parent) {
            arr2.push(item)
        } else {
            arr1.push(item)
            obj[item.id] = item
        }
    }
    let count = 0
    while(count < arr2.length) {
        console.log(1)
        for(let i = 0; i < arr2.length; i++) {
            const item = arr2[i]
            const parent = obj[item.parent]
            if(!obj[item.id]) {
                if(parent) {
                    if(parent.children) {
                        parent.children.push(item)
                    } else {
                        parent.children = [item]
                    }
                    count++
                    obj[item.id] = item
                }
            } 
        }
    }
    return arr1
}

arrayToTree(oriArray)
```





```js
let arr = [{age: 20}, {age: 30}]
let arr1 = [], obj = {}
arr.forEach(item => {
    arr1.push(item)
    obj[item.age] = item
})
undefined
arr1
(2) [{…}, {…}]0: {age: 20}1: {age: 30}length: 2__proto__: Array(0)
obj
{20: {…}, 30: {…}}20: {age: 20}30: {age: 30}__proto__: Object
```

## webpack
1. webpack 了解么？loader、plugin 分别是干嘛的？如何实现一个 loader？
2. webpack 如何优化打包速度；

## React
1. 说一下 react 组件的生命周期；
2. react 组件如何做性能优化，说说 pureComponent；
3. 调用 setState 之后发生了什么;
4. 有用过 hooks 么？怎么看待 hooks？它的原理是；
   
## ES6
1. ES6 symbol 如何使用以及使用场景

2. ES6 Proxy 如何使用以及使用场景，说说 Reflect


3. generator 有什么应用场景

可以用来递归
4. async await 如何实现的


5. commanjs与es6模块化区别




