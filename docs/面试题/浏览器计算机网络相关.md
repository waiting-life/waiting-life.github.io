### cookie，localStorage,sessionStorage
localStorage: 持久化的本地存储，除非主动删除，否则数据一直存在，最大存储量为5Mb
sessionStorage：会话级的本地存储，关闭页面，数据就会被清除，最大存储量为5Mb
cookie：通常使用`Set-Cookie`头部在浏览器种下`Cookie`,`Cookie`存放的数据不能大于4Kb，cookie可以设置过期时间来清除
1. **Cookie与Storage之间的对比**
`Cookie`最大可存储4Kb，`Storage`最大可存储5Mb
`Cookie`可以设置过期时间，`sessionStorage`会话会在会话关闭时清除，`localStorage`必须要手动清除
`Cookie`参与服务器间的通信，而`Storage`不参与
2.  Session
通常使用Session时要搭配上Cookie。
+ 使用Cookie时，会话都存储在Cookie中
+ 使用Session时，Cookie中只存储一个`Session_id`这样的键，实际的会话数据存储在服务端中

**过程**：
小怂第一次访问网站a，注册： 用户名：www，密码：123456，服务端注册，存入数据库（密码加密）     
注册成功后登录，服务端收到用户名密码进行验证，验证成功后，创建一个session对象，吧`session_id`用setCookie传给小怂
登陆成功，响应报文包含Set-Cookie字段，
下次访问网站a的时候，会自动带上Cookie，服务端收到请求，请问报文含有Cookie，就会拿出来和session集合里面的session_id作比较

1、用户向服务器发送用户名和密码。
2、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。
3、服务器向用户返回一个 session_id，写入用户的 Cookie。
4、用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。
5、服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。
3. token存在LocalStorage安全吗？

4. jwt的几个特点
+ JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。
+ JWT 不加密的情况下，不能将秘密数据写入 JWT。
+ JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。
+ JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦   JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。
+ JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为了减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重 要的权限，使用时应该再次对用户进行认证。
+ 为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。

### 跨域
+ cors
+ 设置代理
+ Jsonp
jsonp的限制和原因
1. 如何配置跨域允许携带cookie？子域也能携带cookie吗？
使用CORS的时候默认不会发送cookie，如果想要发送cookie，需要设置`Access-Control-Allow-Credentials`,这个时候也必须为指定源
```js
ctx.set('Access-Control-Allow-Origin', 'http://localhost:3000')
ctx.set('Access-Control-Allow-Crentials', true)
```
**但是**在Chrome的80版本后，Cookie新增了一个叫做sameSite的属性。
sameSite有三个模式：`lax`, `strict`, `none`，默认为lax
strict最严格，表示任何非同站的请求都不能带cookie
lax则只有部分请求可以带上cookie，ajax请求不会带上cookie
none没有任何限制，但是必须使用https
### 浏览器缓存

1. 浏览器缓存机制， 涉及到哪些 http 报文字段？
浏览器缓存分为强制缓存和协商缓存，当浏览器向服务器请求资源的时候，首先会看浏览器是否有资源的缓存
如果没有缓存，则直接向服务器请求资源
如果有缓存，则根据资源的响应头Etag或者Cache-Control:max-age判断缓存是否过期，如果没有过期，则直接读取缓存中的资源，这叫做强制缓存
如果缓存过期了，向服务器发送请求，看资源是否被修改，如果没有修改，则告诉浏览器资源没有被修改，可以直接读取本地缓存中的资源，状态码为304，如果资源过期了，则将修改后的资源作为响应体返回给浏览器，状态码为200，这叫做协商缓存
304
2. Cache-Control有哪些属性?分别表示什么意思
public：表明响应可以被任何对象（包括：发送请求的客户端，代理服务器，等等）缓存，即使是通常不可缓存的内容。（例如：1.该响应没有max-age指令或Expires消息头；2. 该响应对应的请求方法是 POST 。）
private：表明响应只能被单个用户缓存，不能作为共享缓存（即代理服务器不能缓存它）。私有缓存可以缓存响应内容，比如：对应用户的本地浏览器。
no-cache：在发布缓存副本之前，强制要求缓存把请求提交给原始服务器进行验证(协商缓存验证)。
no-store：缓存不应存储有关客户端请求或服务器响应的任何内容，即不使用任何缓存。

3. 协商缓存出于什么原因有Last-Modified,Etag?etag的好处?
为了判断资源是否修改，因为有时候资源没有修改，只是修改了Last-Modified时间，其实文件的内容也没有改变，也应该使用缓存中的资源才对。所以要用etag判断资源内容是否被修改

### 计算机网络
1. TCP和UDP的区别
Tcp是可靠的，面向连接的传输层控制协议
Udp是不可靠的，面向无连接的传输层协议

2. 说一说拥塞控制

3. websocket和http区别 

4. http五层模型，每层有哪些协议，问了下数据链路层干什么，问了https，非对称加密的缺点
应用层：http, ftp(文件传输), smtp(发送电子邮件)
传输层
网络层
数据链路层：用来处理连接网路的硬件部分
物理层

5.  tcp三次握手四次挥手
tcp三次握手
tcp服务端会监听tcp客户端的连接请求
   + 客户端向服务端发起tcp连接请求  SYN=1  seq=x（客户端处于同步已发送阶段
   + 服务端收到后，发送对tcp连接请求的确认  SYN=1 ACK=1 seq=y ack=x+1（服务器处于同步已接受阶段
   + 客户端收到服务端的确认后，发送对服务端确认请求的确认，连接已建立

四次挥手：
  客户端向服务端发送tcp连接释放 FIN=1 ACK=1（中止等待1状态FIN-WAIT-1
  服务端收到后，因为服务端还有可能又数据在传输，就会处于关闭等待阶段，会发送客户端一个普通的确认  ACK=1
客户端收到后，处于中止等待2FIN-WAIT-2
  服务端数据都传送完之后，发送tcp连接始放确认 FIN=1 ACK=1
  客户端收到后处于TIME-WAIT 并向服务端发送确认 ACK=1 
  服务端收到后就会释放连接
  客户端就会在2msl之后关闭连接

不能二次握手
因为比如我们是二次握手的话，假如客户端——>服务端发送的连接请求失效了，客户端没有收到服务端的确认，就会超时重发，这次服务端收到并发送确认后，客户端和服务端建立连接，然后传送数据，最后释放四次挥手释放连接。客户端和服务器都处于关闭状态，这时候如果之前失效的tcp连接请求发送到tcp服务器后，tcp服务器就会向客户端发送确认报文，但是因为tcp客户端已经关闭，并不会理会服务器。服务器没收到就会不断的超时重发，浪费资源

6. 线程和进程区别 
进程是运行中的程序，线程是进程的内部的一个执行序列
进程是资源分配的单元，线程是执行行单元
进程间切换代价大，线程间切换代价小
进程拥有资源多，线程拥有资源少
多个线程共享进程的资源（一个进程可以有多个线程）

7. 什么是CDN

8. 浏览器的请求方式，有什么区别？
GET: 获取资源
POST：传输实体主体
PUT：传输文件（http1.1的put方法不带验证机制，任何人都可以上传文件，存在安全问题）
DELETE：删除文件
HEAD：获取报文首部（不返回报文的主体部分，用于确认资源的有效性和修改时间等）
OPTIONS：询问支持的方法（OPTIONS用来查询针对请求指定的资源支持的方法）
9.  输入url之后发生了什么
+ 首先解析url获取协议，域名和端口
+ 查看浏览器是否有资源的缓存，如果有缓存的话
  + 根据资源的响应头`Expires`或者`Cache-control:max-age`判断缓存是否过期，如果没有过期，直接读取缓存中的资源 —— 强制缓存
  + 如果缓存过期了，则向服务器发送请求判断资源是否被修改，如果没有被修改则告诉浏览器直接读取本地缓存中的资源，状态码为304
   + 如果资源的响应头有`Etag`头部，则请求的时候带上`if-None-Match`头部
   + 如果资源的响应头有`Last-Modified`，则请求的时候带上`If-Modified-Since`
  + 如果资源修改了，则将修改后的资源作为响应体返回给浏览器，状态码为200
如果没有缓存的话进行下一步
+ 进行DNS解析，获取域名对应的ip地址
  + 查看浏览器是否有缓存，若没有
  + 查看操作系统有没有缓存，若没有
  + 查看本地hosts文件有没有域名和ip的对应关系，若没有
  + 查找路由器中是否有缓存，若没有
  + 查看DNS服务器是否有缓存，若没有
  + 向根域名服务器发送请求
+ 生成HTTP请求，向服务器发送HTTP请求
+ 服务器收到请求后，返回响应
+ 浏览器收到响应后，解析HTML为DOM树
+ 解析CSS为CSSOM树
+ 将DOM树和CSSOM树结合生成渲染树
+ 布局，获取每个徐娜然对象的位置和尺寸
+ 绘制，将计算好的像素绘制到屏幕上
